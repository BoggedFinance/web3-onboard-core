import fs from 'fs/promises';
import path from 'path';
import glob from 'glob-promise';
import globParent from 'glob-parent';
import { getOptions } from '@rollup-extras/utils/options';
import logger from '@rollup-extras/utils/logger';

const factories = { targets, logger };
function index (options) {
    const files = new Map();
    const normalizedOptions = getOptions(options, {
        pluginName: '@rollup-extras/plugin-copy',
        copyOnce: true,
        flattern: false,
        verbose: false,
        exactFileNames: true,
        watch: true,
        emitFiles: true,
        outputPlugin: false
    }, 'targets', factories);
    const { pluginName, copyOnce, verbose, exactFileNames, targets, outputPlugin, flattern, emitFiles, logger } = normalizedOptions;
    let { watch } = normalizedOptions;
    const hookName = outputPlugin ? 'generateBundle' : emitFiles ? 'buildStart' : 'buildEnd';
    if (!outputPlugin && !emitFiles && watch) {
        watch = false;
        logger('can\'t use watch with emitFiles = false and outputPlugin = false', 0 /* verbose */);
    }
    if (outputPlugin && watch) {
        watch = false;
        logger('can\'t use watch with outputPlugin = true', 0 /* verbose */);
    }
    return {
        name: pluginName,
        async [hookName]() {
            const results = await Promise.all(targets.map(target => glob(target.src, { ignore: target.exclude })
                .then((result) => ({
                src: result,
                dest: target.dest ? target.dest : '',
                parent: globParent(target.src)
            }))));
            for (const result of results) {
                for (const file of result.src) {
                    let fileDesc;
                    if (files.has(file)) {
                        fileDesc = files.get(file);
                    }
                    else {
                        fileDesc = {
                            dest: [],
                            copied: [],
                            timestamp: 0
                        };
                        files.set(file, fileDesc);
                    }
                    const dest = flattern ? normalizeSlash(result.dest) : path.join(result.dest, path.relative(result.parent, path.dirname(file)));
                    if (!fileDesc.dest.includes(dest)) {
                        fileDesc.dest.push(dest);
                    }
                    // don't forget to watch it
                    if (watch) {
                        this.addWatchFile(file);
                    }
                }
            }
            const statistics = [];
            logger.start('coping files', verbose ? 1 /* info */ : 0 /* verbose */);
            for (const [fileName, fileDesc] of files) {
                try {
                    const fileStat = await fs.stat(fileName);
                    if (!fileStat.isFile() && !fileStat.isSymbolicLink()) {
                        continue;
                    }
                    const timestamp = fileStat.mtime.getTime();
                    if (timestamp > fileDesc.timestamp) {
                        fileDesc.timestamp = timestamp;
                        fileDesc.copied = [];
                    }
                    let source;
                    if (emitFiles) {
                        source = await fs.readFile(fileName);
                    }
                    for (const dest of fileDesc.dest) {
                        if (copyOnce && fileDesc.copied.includes(dest)) {
                            continue;
                        }
                        const baseName = path.basename(fileName);
                        // path.join removes ./ from the beginning, that's needed for rollup name/fileName fields
                        const destFileName = path.join(dest, baseName);
                        if (emitFiles) {
                            this.emitFile({
                                type: 'asset',
                                [exactFileNames ? 'fileName' : 'name']: destFileName,
                                source
                            });
                        }
                        else {
                            await fs.mkdir(path.dirname(destFileName), { recursive: true });
                            await fs.copyFile(fileName, destFileName);
                        }
                        statistics.push(baseName);
                        fileDesc.copied.push(dest);
                    }
                }
                catch (e) { // eslint-disable-line @typescript-eslint/no-explicit-any
                    const loglevel = e['code'] === 'ENOENT' ? undefined : 2 /* warn */;
                    logger(`error reading file ${fileName}`, loglevel, e);
                }
            }
            logger.finish(`copied ${statistics.length > 5 ? statistics.length + ' files' : statistics.join(', ')}`);
        }
    };
}
function normalizeSlash(dir) {
    if (dir.endsWith('/')) {
        return `${dir.substring(0, dir.length - 1)}`;
    }
    return dir;
}
function targets(options, field) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let targets = options[field];
    if (targets == null) {
        targets = [options];
    }
    if (Array.isArray(targets)) {
        targets = targets.map((item) => {
            if (item) {
                if (typeof item === 'string') {
                    return { src: item };
                }
                if (typeof item === 'object' && 'src' in item) {
                    return item;
                }
            }
            return undefined;
        }).filter(Boolean);
    }
    return targets;
}

export { index as default };
