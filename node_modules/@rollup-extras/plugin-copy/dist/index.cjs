'use strict';

var fs = require('fs/promises');
var path = require('path');
var glob = require('glob-promise');
var globParent = require('glob-parent');
var options = require('@rollup-extras/utils/options');
var logger = require('@rollup-extras/utils/logger');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var glob__default = /*#__PURE__*/_interopDefaultLegacy(glob);
var globParent__default = /*#__PURE__*/_interopDefaultLegacy(globParent);
var logger__default = /*#__PURE__*/_interopDefaultLegacy(logger);

const factories = { targets, logger: logger__default["default"] };
function index (options$1) {
    const files = new Map();
    const normalizedOptions = options.getOptions(options$1, {
        pluginName: '@rollup-extras/plugin-copy',
        copyOnce: true,
        flattern: false,
        verbose: false,
        exactFileNames: true,
        watch: true,
        emitFiles: true,
        outputPlugin: false
    }, 'targets', factories);
    const { pluginName, copyOnce, verbose, exactFileNames, targets, outputPlugin, flattern, emitFiles, logger } = normalizedOptions;
    let { watch } = normalizedOptions;
    const hookName = outputPlugin ? 'generateBundle' : emitFiles ? 'buildStart' : 'buildEnd';
    if (!outputPlugin && !emitFiles && watch) {
        watch = false;
        logger('can\'t use watch with emitFiles = false and outputPlugin = false', 0 /* verbose */);
    }
    if (outputPlugin && watch) {
        watch = false;
        logger('can\'t use watch with outputPlugin = true', 0 /* verbose */);
    }
    return {
        name: pluginName,
        async [hookName]() {
            const results = await Promise.all(targets.map(target => glob__default["default"](target.src, { ignore: target.exclude })
                .then((result) => ({
                src: result,
                dest: target.dest ? target.dest : '',
                parent: globParent__default["default"](target.src)
            }))));
            for (const result of results) {
                for (const file of result.src) {
                    let fileDesc;
                    if (files.has(file)) {
                        fileDesc = files.get(file);
                    }
                    else {
                        fileDesc = {
                            dest: [],
                            copied: [],
                            timestamp: 0
                        };
                        files.set(file, fileDesc);
                    }
                    const dest = flattern ? normalizeSlash(result.dest) : path__default["default"].join(result.dest, path__default["default"].relative(result.parent, path__default["default"].dirname(file)));
                    if (!fileDesc.dest.includes(dest)) {
                        fileDesc.dest.push(dest);
                    }
                    // don't forget to watch it
                    if (watch) {
                        this.addWatchFile(file);
                    }
                }
            }
            const statistics = [];
            logger.start('coping files', verbose ? 1 /* info */ : 0 /* verbose */);
            for (const [fileName, fileDesc] of files) {
                try {
                    const fileStat = await fs__default["default"].stat(fileName);
                    if (!fileStat.isFile() && !fileStat.isSymbolicLink()) {
                        continue;
                    }
                    const timestamp = fileStat.mtime.getTime();
                    if (timestamp > fileDesc.timestamp) {
                        fileDesc.timestamp = timestamp;
                        fileDesc.copied = [];
                    }
                    let source;
                    if (emitFiles) {
                        source = await fs__default["default"].readFile(fileName);
                    }
                    for (const dest of fileDesc.dest) {
                        if (copyOnce && fileDesc.copied.includes(dest)) {
                            continue;
                        }
                        const baseName = path__default["default"].basename(fileName);
                        // path.join removes ./ from the beginning, that's needed for rollup name/fileName fields
                        const destFileName = path__default["default"].join(dest, baseName);
                        if (emitFiles) {
                            this.emitFile({
                                type: 'asset',
                                [exactFileNames ? 'fileName' : 'name']: destFileName,
                                source
                            });
                        }
                        else {
                            await fs__default["default"].mkdir(path__default["default"].dirname(destFileName), { recursive: true });
                            await fs__default["default"].copyFile(fileName, destFileName);
                        }
                        statistics.push(baseName);
                        fileDesc.copied.push(dest);
                    }
                }
                catch (e) { // eslint-disable-line @typescript-eslint/no-explicit-any
                    const loglevel = e['code'] === 'ENOENT' ? undefined : 2 /* warn */;
                    logger(`error reading file ${fileName}`, loglevel, e);
                }
            }
            logger.finish(`copied ${statistics.length > 5 ? statistics.length + ' files' : statistics.join(', ')}`);
        }
    };
}
function normalizeSlash(dir) {
    if (dir.endsWith('/')) {
        return `${dir.substring(0, dir.length - 1)}`;
    }
    return dir;
}
function targets(options, field) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let targets = options[field];
    if (targets == null) {
        targets = [options];
    }
    if (Array.isArray(targets)) {
        targets = targets.map((item) => {
            if (item) {
                if (typeof item === 'string') {
                    return { src: item };
                }
                if (typeof item === 'object' && 'src' in item) {
                    return item;
                }
            }
            return undefined;
        }).filter(Boolean);
    }
    return targets;
}

module.exports = index;
